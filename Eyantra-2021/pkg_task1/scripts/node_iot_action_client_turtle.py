#!/usr/bin/env python
"""
ROS Node - Simple Action Client - Turtle & Action Client -Mqtt"""

import rospy
import actionlib
# Message Class that is used by ROS Actions internally and for Goal messages and Result Messages
from pkg_task1.msg import msgTurtleAction, msgTurtleGoal
# Message Class that is used by ROS Actions internally and for goal message and result
from pkg_ros_iot_bridge.msg import msgRosIotAction, msgRosIotGoal, msgRosIotResult
# Message Class that is used to send mqtt Messages
from pkg_ros_iot_bridge.msg import msgMqttSub

"""
This class implement Action Client for sending goal to Action Server"""

class IotRosBridgeActionClient:

    # Constructor
    def __init__(self):

        # Initialize Action Client
        self._ac = actionlib.ActionClient('/action_iot_ros',
                                          msgRosIotAction)
        # Dictionary to Store all the goal handels
        self.goal_handles = {}
        # Wait for Action Server that will use the action - '/action_iot_ros' to start
        self._ac.wait_for_server()
        rospy.loginfo("Action server up, we can send goals.")

    # This function will be called when there is a change of state in the Action Client State Machine
    def on_transition(self, goal_handle):

        # from on_goal() to on_transition(). goal_handle generated by send_goal() is used here.
        result = msgRosIotResult()

        index = 0
        for i in self.goal_handles:
            if self.goal_handles[i] == goal_handle:
                index = i
                break

        rospy.loginfo(
            "Transition Callback. Client Goal Handle #: " + str(index))
        rospy.loginfo("Comm. State: " + str(goal_handle.get_comm_state()))
        rospy.loginfo("Goal Status: " + str(goal_handle.get_goal_status()))

        # Comm State - Monitors the State Machine of the Client which is different from Server's
        # Comm State = 2 -> Active
        # Comm State = 3 -> Wating for Result
        # Comm State = 7 -> Done

        # if (Comm State == ACTIVE)
        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(index) + ": Goal just went active.")

        # if (Comm State == DONE)
        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(index) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())

            # get_result() gets the result produced by the Action Server
            result = goal_handle.get_result()
            rospy.loginfo(result.flag_success)

            if (result.flag_success == True):
                rospy.loginfo(
                    "Goal successfully completed. Client Goal Handle #: " + str(index))
            else:
                rospy.loginfo(
                    "Goal failed. Client Goal Handle #: " + str(index))

    # This function is used to send Goals to Action Server
    def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message):
        # Create a Goal Message object
        goal = msgRosIotGoal()

        goal.protocol = arg_protocol
        goal.mode = arg_mode
        goal.topic = arg_topic
        goal.message = arg_message

        rospy.loginfo("Sending goal.")

        # self.on_transition - It is a function pointer to a function which will be called when
        #                       there is a change of state in the Action Client State Machine
        goal_handle = self._ac.send_goal(goal,
                                         self.on_transition,
                                         None)
        return goal_handle


"""
This class implement Simple action client to send goal to simple action server to move turtle"""

class SimpleActionClientTurtle:
    # Constructor
    def __init__(self, iot_action_client):
        # Initialize Simple Action Client to send Action on Turtle_action handler server
        self.ac = actionlib.SimpleActionClient(
            '/action_turtle', msgTurtleAction)
        # Wait for Action Server that will use the action - '/action_turtle' to start
        self.ac.wait_for_server()
        rospy.loginfo(
            " Simple Action server is up, we can send new goals! to move turtle")

        self.iot_action_client = iot_action_client

        # Store the MQTT Topic on which to Publish in a variable
        param_config_iot = rospy.get_param('config_iot')
        self.config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
        self.mqtt_sub_topic = param_config_iot['mqtt']['sub_cb_ros_topic']
        self.http_sub_topic = param_config_iot['google_apps']['spread_sheet_id']

    # Function to send goal to simple action server for moving turtle by specified distance and angle
    def send_goal(self, arg_dis, arg_angle):

        # Create Goal message for Simple Action Server
        goal = msgTurtleGoal(distance=arg_dis, angle=arg_angle)

        '''
            * done_cb is set to the function pointer of the function which should be called once 
                the Goal is processed by the Simple Action Server.

            * feedback_cb is set to the function pointer of the function which should be called while
                the goal is being processed by the Simple Action Server.
        '''
        self.ac.send_goal(goal, done_cb=self.done_callback,
                          feedback_cb=self.feedback_callback)

        rospy.loginfo("Goal has been sent.")

    # Function print result on Goal completion and send result to ros_iot_bridge server
    def done_callback(self, status, result):
        rospy.loginfo("Status is : " + str(status))
        rospy.loginfo("Result is : " + str((result.final_x,
                                            result.final_y, result.final_theta)))

        self.goal_to_ros_iot_bridge(result)

    # Function to print feedback while Goal is being processed
    def feedback_callback(self, feedback):
        feedback_message = "(current_x,current_y,current_theta)=" + \
            str((feedback.cur_x, feedback.cur_y, feedback.cur_theta))
        rospy.loginfo(feedback_message)

    # Function to send goal to ros_iot_bridge action server
    def goal_to_ros_iot_bridge(self, result):

        rospy.loginfo("Sending Mqtt Goal")

        message = str((result.final_x, result.final_y, result.final_theta))
        goal1 = self.iot_action_client.send_goal(
            "mqtt", "pub", self.config_mqtt_pub_topic, message)
        self.iot_action_client.goal_handles[1] = goal1

        rospy.loginfo("Sending HTTP Goal")

        message = str({"id":"task1", "team_id":"VB_1544", "unique_id":"AnChRiVi","turtle_x":result.final_x,
                        "turtle_y":result.final_y, "turtle_theta":result.final_theta})

        #message = str({"id": "Sheet1", "turtle_x": result.final_x,
                       #"turtle_y": result.final_y, "turtle_theta": result.final_theta})
        goal2 = self.iot_action_client.send_goal(
            "http", "NA", self.http_sub_topic, message)
        self.iot_action_client.goal_handles[2] = goal2


"""
Callback function which send goal when start message recieved on subscribed topic"""

def draw_hexagone(msg, args):

    if msg.message == "start":
        obj_client = args[0]

        # 3. Send Goals to Draw a Hexagone
        obj_client.send_goal(2, 0)
        obj_client.ac.wait_for_result()
        rospy.sleep(2)

        obj_client.send_goal(2, 60)
        obj_client.ac.wait_for_result()
        rospy.sleep(2)

        obj_client.send_goal(2, 60)
        obj_client.ac.wait_for_result()
        rospy.sleep(2)

        obj_client.send_goal(2, 60)
        obj_client.ac.wait_for_result()
        rospy.sleep(2)

        obj_client.send_goal(2, 60)
        obj_client.ac.wait_for_result()
        rospy.sleep(2)

        obj_client.send_goal(2, 60)
        obj_client.ac.wait_for_result()
        rospy.sleep(2)


# Main Function
def main():
    # 1. Initialize ROS Node
    rospy.init_node('node_simple_action_client_turtle')

    # 2. Create a object for  Action Client .
    iot_action_client = IotRosBridgeActionClient()

    # 3. Create a object for simple Action Client and pass Action Client object to acess this class
    obj_client = SimpleActionClientTurtle(iot_action_client)

    # 4. Subscribe too a topic to recieve start message and pass  simple Action Client object
    #   to send goal to server by callback function
    rospy.Subscriber(obj_client.mqtt_sub_topic, msgMqttSub,
                     draw_hexagone, (obj_client,))

    # 5. Loop forever
    rospy.spin()


if __name__ == '__main__':
    main()
